<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

// console.log(object)//构造函数
// console.dir({})//实例




//object 静态方法
// 1.object.keys 返回键名数组
var person = {
    age:24,
    name:'tony',
}
console.log(Object.keys(person))

// 2.object.assign  扩展对象  （不支持深拷贝）
var obj1 = {name:'tony'};
var obj2 = {age:24};
var obj3 = {name:'kevin',gender:'男'};
console.log(Object.assign({},obj1,obj2,obj3));


// 3.object.freeze  冻结对象，浅冻结
var config = Object.freeze({
    dely:5000,
    autoplay:false,
    info:{gender:'女'}
});
config.dely = 6000;
delete config.dely;

config.info.gender='女';
console.log(config);

// 4.object.is 判断两个值是否相等
console.log(0 == -0)//true
console.log(Object.is(0,-0))//false
console.log(NaN == NaN)//false
console.log(Object.is(NaN,NaN))//true





// isprototypeof 判断一个对象是否在另一个对象的原型链上

function person(){

};
person.prototype.age = 24;
var p1 = new person();

console.log( person.prototype.isProptypeOf(p1));
console.log(p1.age);

console.log({}.isProptypeOf(p1))




//设置原型方法1
var obj1 = {};
obj1._proto_={age:24,name:'tony'};
console.log(obj1);


//设置原型方法2
var obj2 = {};
Object.setPrototypeOf(obj2,{age:24,name:'tony'});
console.log(obj2);


//object.getprototypeof  获取原型对象
var obj3 = {};
var dog = {age:1,name:'花花'};
obj3._proto_= dog;
console.log(Object.getPrototypeOf(obj3)=== dog)//?true



















    </script>
</body>
</html>